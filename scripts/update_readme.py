import os
import re

def get_solution_files():
    """Gets all Python solution files from the 'solutions' directory."""
    solutions_dir = 'solutions'
    if not os.path.exists(solutions_dir):
        return []
    # Ensure consistent order by sorting
    return sorted([f for f in os.listdir(solutions_dir) if f.endswith('.py')])

def title_case_from_slug(slug):
    """Converts a slug-like-string to Title Case."""
    return ' '.join(word.capitalize() for word in slug.split('-'))

def parse_solution_file(filename):
    """
    Parses metadata from a solution file's name and content.
    Filename is expected to be in the format: <number>.<slug-title>.py
    """
    # Parse filename
    match = re.match(r'(\d+)\.(.+)\.py', filename)
    if not match:
        return None
    
    number, slug = match.groups()

    metadata = {
        'no': int(number),
        'slug': slug,
        'title': title_case_from_slug(slug),
        'difficulty': 'N/A',
        'category': 'N/A',
        'filename': filename
    }

    # Parse comments in the file for more metadata
    with open(os.path.join('solutions', filename), 'r', encoding='utf-8') as f:
        for line in f:
            if line.startswith('# Difficulty:'):
                metadata['difficulty'] = line.split(':', 1)[1].strip()
            elif line.startswith('# Category:'):
                metadata['category'] = line.split(':', 1)[1].strip()
            # Stop parsing after the header comments
            elif not line.startswith('#'):
                break
    return metadata

def generate_readme_content(solutions_metadata):
    """Generates the entire content for the README.md file."""
    
    # 1. Header
    header = """# LeetCode Python Solutions

This repository contains my solutions to LeetCode problems, implemented in Python. The goal is to solve one LeetCode problem every day.

Inspired by [mzyui/leetcode-rs](https://github.com/mzyui/leetcode-rs).

"""

    # 2. Problem Index
    index_header = "## Problem Index\n\n"
    # Use a triple-quoted string for the table header for clarity and to avoid syntax errors.
    table_header = """| # | Title | Difficulty | Category | Solution |
|---|---|---|---|---|
"""
    
    table_rows = []
    for meta in solutions_metadata:
        solution_path = f"./solutions/{meta['filename']}"
        row = f"| {meta['no']} | {meta['title']} | {meta['difficulty']} | {meta['category']} | [Python]({solution_path}) |"
        table_rows.append(row)
    
    problem_index = index_header + table_header + "\n".join(table_rows) + "\n"

    # 3. Footer / Other sections
    footer = """
## Project Structure

*   `solutions/`: Contains the Python solution files for each LeetCode problem.
*   `scripts/`: Contains utility scripts, including the script to update this README.
*   `README.md`: This file, which is auto-generated by a script.

## Workflow

1.  Add a new solution file to the `solutions/` directory, following the naming convention: `<number>.<slug-title>.py`.
2.  Add comments to the top of the file for `Difficulty` and `Category`.
3.  Run the update script: `python scripts/update_readme.py`.
4.  The script will automatically regenerate this `README.md` to include the new solution.
"""
    
    return header + problem_index + footer

def main():
    """Main function to run the script."""
    print("Starting README regeneration process...")
    
    solution_files = get_solution_files()
    if not solution_files:
        print("No solution files found. README will be generated with an empty index.")

    # Parse all found solution files
    solutions_metadata = []
    for filename in solution_files:
        meta = parse_solution_file(filename)
        if meta:
            solutions_metadata.append(meta)
        else:
            print(f"Warning: Could not parse filename '{filename}'. It will be skipped.")

    # Sort solutions by problem number
    solutions_metadata.sort(key=lambda x: x['no'])
    
    print(f"Found and parsed {len(solutions_metadata)} solution(s). Generating new README content...")
    readme_content = generate_readme_content(solutions_metadata)
    
    print("Writing new content to README.md...")
    with open('README.md', 'w', encoding='utf-8') as f:
        f.write(readme_content)
        
    print("README.md has been successfully regenerated.")

if __name__ == '__main__':
    main()